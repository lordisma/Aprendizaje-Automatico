knitr::opts_chunk$set(echo = TRUE)
par( mfrow = c( 1, 1 ) )
# Funciones facilitdas
set.seed(3)	# se establece la semilla
## ------------------------------------------------------------------------
# por defecto genera 2 puntos entre [0,1] de 2 dimensiones
simula_unif = function (N=2,dims=2, rango = c(0,1)){
m = matrix(runif(N*dims, min=rango[1], max=rango[2]),
nrow = N, ncol=dims, byrow=T)
m
}
simula_gaus = function(N=2,dim=2,sigma){
if (missing(sigma)) stop("Debe dar un vector de varianzas")
sigma = sqrt(sigma)  # para la generaci??n se usa sd, y no la varianza
if(dim != length(sigma)) stop ("El numero de varianzas es distinto de la dimensi??n")
simula_gauss1 = function() rnorm(dim, sd = sigma) # genera 1 muestra, con las desviaciones especificadas
m = t(replicate(N,simula_gauss1())) # repite N veces, simula_gauss1 y se hace la traspuesta
m
}
simula_recta = function (intervalo = c(-1,1), visible=F){
ptos = simula_unif(2,2,intervalo) # se generan 2 puntos
a = (ptos[1,2] - ptos[2,2]) / (ptos[1,1]-ptos[2,1]) # calculo de la pendiente
b = ptos[1,2]-a*ptos[1,1]  # calculo del punto de corte
if (visible) {  # pinta la recta y los 2 puntos
if (dev.cur()==1) # no esta abierto el dispositivo lo abre con plot
plot(1, type="n", xlim=intervalo, ylim=intervalo)
points(ptos,col=3)  #pinta en verde los puntos
abline(b,a,col=3)   # y la recta
}
c(a,b) # devuelve el par pendiente y punto de corte
}
pintar_frontera = function(f,rango=c(-50,50)) {
x=y=seq(rango[1],rango[2],length.out = 500)
z = outer(x,y,FUN=f)
if (dev.cur()==1) # no esta abierto el dispositivo lo abre con plot
plot(1, type="n", xlim=rango, ylim=rango)
contour(x,y,z, levels = 1:20, xlim =rango, ylim=rango, xlab = "x", ylab = "y")
}
N <- 50
size <- 50
range = c( -size, size )
sigma <- c( 5, 7 )
dataUnif <- simula_unif( N, rango = range )
dataGaus <- simula_gaus( N, sigma = sigma )
plot(
rbind( dataUnif, dataGaus ),
col = c( rep(3,N), rep(5,N) )
)
line <- simula_recta( intervalo = c( -size, size ) )
a <- line[1]
b <- line[2]
f <- function( v ) {
sign( v[2] - a * v[1] - b )
}
lineFunc <- function( x ) {
a * x + b
}
dataAll <- rbind( dataUnif, dataGaus )
labels <- apply( dataAll, FUN = f, MARGIN = 1 )
lineX <- c( -range, range )
lineY <- c( lineFunc(-range), lineFunc(range) )
noise <- function( labels, p = 0.1 ){
# Ver dÃ³nde estÃ¡ cada positivo y negativo
positives <- c()
negatives <- c()
posSize <- length( labels[ labels == 1 ] )
negSize <- length( labels[ labels == -1 ] )
for ( i in 1:length(labels) )
if ( labels[i] == 1 )
positives <- c( positives, i )
else
negatives <- c( negatives, i )
# Generar las posiciones que se alterarÃ¡n
posPositions <- sample( 1:posSize, posSize * p )
negPositions <- sample( 1:negSize, negSize * p )
labels[ posPositions ] = -1
labels[ negPositions ] = 1
labels
}
plot( dataAll, col = labels + 4 )
lines( lineX, lineY, col = "black" )
labels <- noise( labels )
plot( dataAll, col = labels + 4 )
lines( lineX, lineY, col = "black" )
f1 <- function( v ) {
sign( ( v[1] - 10 ) ^2 + ( v[2] - 20 ) ^2 - 400 )
}
f2 <- function( v ) {
sign( 0.5 * ( v[1] + 10 ) ^2 + ( v[2] - 20 ) ^2 - 400 )
}
f3 <- function( v ) {
sign( 0.5 * ( v[1] - 10 ) ^2 - ( v[2] + 20 ) ^2 - 400 )
}
f4 <- function( v ) {
sign( v[2] - 20 * v[1] ^2 - 5 * v[1] + 3 )
}
labels1 <- apply( dataAll, FUN = f1, MARGIN = 1 )
labels2 <- apply( dataAll, FUN = f2, MARGIN = 1 )
labels3 <- apply( dataAll, FUN = f3, MARGIN = 1 )
labels4 <- apply( dataAll, FUN = f4, MARGIN = 1 )
plot( dataAll, col = labels1 + 4, main = "f1(x,y) = ( x - 10 ) ^2 + ( y - 20 ) ^2 - 400" )
plot( dataAll, col = labels2 + 4, main = "f2(x,y) = 0.5 ( x + 10 ) ^2 + ( y - 20 ) ^2 - 400" )
plot( dataAll, col = labels3 + 4, main = "f3(x,y) = 0.5 () x - 10 ) ^2 - ( y + 20 ) ^2 - 400" )
plot( dataAll, col = labels4 + 4, main = "f4(x,y) = y - 20 x ^2 - 5 x + 3" )
dataUnif <- simula_unif( N, rango = range )
dataGaus <- simula_gaus( N, sigma = sigma )
data <- rbind( dataUnif, dataGaus )
data <- cbind(data,1)
labels <- apply( data, FUN = f, MARGIN = 1 )
dims <- 2
weightsZero <- rep( 0, dims + 1 )
weightsUnif <- simula_unif( dims + 1, dims = 1, rango = c(0,1) )
maxIterations = 10
PLA <- function( X, Y, startWeights, learningRate = 0.01, maxIterations ){
i <- 0
threashold <- 0.01
ascending <- TRUE
weights <- startWeights
prevWeights <- weights
while ( i < maxIterations & ascending ){ #while(abs(w_predecesors - weights))
ascending <- FALSE
for ( elem in 1:length(Y) ){
valor_predict = sign( as.numeric( t(weights) %*% X[elem,] ) )
wellClassified = valor_predict * Y[elem]
if ( wellClassified < 0 ){
weights = weights + learningRate * X[elem,] * wellClassified
ascending <- TRUE
}
}
i <- i + 1
}
weights
}
weights <- PLA( data, labels, weightsZero, 1, maxIterations )
weights <- PLA( data, labels, weightsUnif, 1, maxIterations )
scorer <- function( data, labels, weights ){
sum <- 0
#errores_A <- 0
N <- length(labels)
for ( i in 1:N ){
h <- ( t(weights) %*% data[i,] )
goal <- h * labels[i]
sum <- ifelse(goal > 0, sum +1, sum)
# errores_A <- ifelse((goal < 0) && (h > 0), errores_A +1, errores_A)
}
sum/N
}
PLA <- function( X, Y, startWeights, learningRate = 0.01, maxIterations ){
i <- 0
threashold <- 0.01
ascending <- TRUE
weights <- startWeights
prevWeights <- weights
bestWeights <- weights
bestScore <- scorer( X, Y, weights )
while ( i < maxIterations & ascending ){ #while(abs(w_predecesors - weights))
ascending <- FALSE
for ( elem in 1:length(Y) ){
valor_predict = sign( as.numeric( t(weights) %*% X[elem,] ) )
wellClassified = valor_predict * Y[elem]
if ( wellClassified < 0 ){
weights = weights + learningRate * X[elem,] * wellClassified
ascending <- TRUE
}
}
i <- i + 1
newScore <- scorer( X, Y, weights )
if ( newScore > bestScore ){
bestScore <- newScore
bestWeights <- weights
}
}
bestWeights
}
N <- 100
size <- 2
range = c( -size, size )
data <- simula_unif( N, rango = range )
lineX <- simula_unif( 2, dims = 1, rango = range )
lineY <- simula_unif( 2, dims = 1, rango = range )
f <- function(x){
( lineY[2] - lineY[1] ) / ( lineX[2] - lineX[1] ) * ( x - lineX[1] ) / lineX[2]
}
labels <- apply( data, FUN = f, MARGIN = 1 )
data <- cbind( data, 1 )
N <- 1000
dataTest <- simula_unif( N, rango = range )
labels <- apply( dataTest, FUN = f, MARGIN = 1 )
dataTest <- cbind( dataTest, 1 )
